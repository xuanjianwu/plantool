#+TITLE: PlanTool Documentation
* Introduction
  Plantool wraps different planners into a python utility package. It aims to provide convenience for planning study and applications.
* Installation
* Planners
** Deterministic
   Deterministic planners
*** SGPlan
     - Usage for SGPlan: 
     #+BEGIN_SRC python
     >>> import sgplan
     >>> argv = ['sgplan', '-o', 'domain.pddl', '-f', 'problem.pddl']
     >>> sgplan.oldmain(argv)
     #+END_SRC
    
     - Instructions about arguments:

       | OPTIONS   | DESCRIPTIONS       |
       |-----------+--------------------|
       | -o <str>  | operator file name |
       | -f  <str> | fact file name     |


*** SatPlan2006
     - Usage for SATplan:  
       #+BEGIN_SRC python
       >>> import satplan  
       >>> argv=['bb','-o','domain.pddl','-f','problem.pddl','-l','5','-G','0','-C','2']  
       >>> satplan.run(argv)  
       #+END_SRC
     
     - Instructions about arguments:

       | OPTIONS     | DESCRIPTIONS                                                       |
       |-------------+--------------------------------------------------------------------|
       | -o <str>    | operator file name                                                 |
       | -f  <str>   | fact file name                                                     |
       | -p  <str>   | path for operator and fact file                                    |
       | -l  <num>   | goal layer for CNF                                                 |
       | -G <0 or 1> | (0) create CNF output or (1) build final solution                  |
       | -b  <str>   | CNF output file name                                               |
       | -t <0 or 1> | (1) CNF output includes only unary/binary clauses - others ignored |
       | -S  <str>   | Input Solution File Name (only when -G 1 is used)                  |
       | -F  <str>   | Final Output Solution File Name (only when -G 1 is used)           |
       | -V  <str>   | Variables File Name - list all variables (only when -G 1 is used)  |
       | -C          | CNF formula output (preset: -1); at layer <-l>                     |
       | -C 0        | none                                                               |
       | -C 1        | action-based                                                       |
       | -C 2        | gp-style action-based                                              |
       | -C 3        | gp-based                                                           |
       | -C 4        | thin gp-based                                                      |
      
   
*** HSP
    - Usage for HSP: 
      #+BEGIN_SRC python
      >>> import hsp
      >>> argv = ['hsp', '-o', 'domain.pddl', '-f', 'problem.pddl']
      >>> hsp.run(argv)
      #+END_SRC

    - Instructions about arguments:
 
      | OPTIONS   | DESCRIPTIONS                                                              |
      |-----------+---------------------------------------------------------------------------|
      | -o  <str> | operator file name                                                        |
      | -f  <str> | <str>    fact file name                                                   |
      | -a  <str> | <str>    Algorithm, either 'bfs' or 'gbfs'.                               |
      | -d  <str> | <str>    Search direction, either 'forward' or 'backward'.                |
      | -h  <str> | <str>    Heuristic function, one of 'h1plus', 'h1max', 'h2plus', 'h2max'. |
      | -v  <num> | <num>    Verbose level >= 0 (default is 1).                               |
      | -w  <float> | <float>   Float to weight the heuristic component of the cost             |


*** LAMA
    - Usage for LAMA:
    1. First,run:
      #+BEGIN_SRC python
      >>> import translate
      >>> argv = ['translate','domain.pddl','problem.pddl']
      >>> translate.main(argv)
      #+END_SRC
      - translate
        The translator will will write its result to a file called
        "output.sas", which serves as an input to the next phase, knowledge
        compilation. The translator also writes a file called
        "test.groups", which is some sort of translation key (see
        "sas-format.txt" in the documentation directory mentioned above).
        This second file is not needed by the planner, but might help you
        understand what the translated task looks like. It also writes a
        file called "all.groups" which is needed by the landmark heuristic.

    2. Second, run:
       #+BEGIN_SRC python
       >>> import preprocess
       >>> argv = ['preprocess','< output.sas']
       >>> preprocess.oldmain(argv)
       #+END_SRC

       - preprocess
         This will run the knowledge compilation component, writing its
         output to the file aptly named "output".

    3. Finally, run:
       #+BEGIN_SRC python
       >>> import search
       >>> argv = ['search','f','< output']
       >>> search.oldmain(argv)
       #+END_SRC

       - search
         note 
         This runs the search component of the planner. On success, it will
         write a file called "sas_plan" containing the plan.
         OPTIONS DESCRIPTIONS
         l:  Use the landmark heuristic.
         L:  Use preferred operators of the landmark heuristic.
         f:  Use the FF heuristic.
         F:  Use helpful actions ("preferred operators" of the FF
         heuristic).


*** GP-CSP
    
    - Usage for GP-CSP
      #+BEGIN_SRC python
      >>> import gpcsp
      >>> argv = ['gpcsp', '-o', 'domain.pddl', '-f', 'problem.pddl']
      >>> gpcsp.run(argv)
      #+END_SRC

    - Instructions about arguments:
      | OPTIONS          | DESCRIPTIONS                                                     |
      | -h               | for this list                                                    |
      | -o <op file>     | to specify operator file                                         |
      | -f <fact file>   | to specify fact file                                             |
      | -t <integer>     | to specify a fixed number of time steps                          |
      | -i <info level>  | to specify info level 1 or 2 (default is 0)                      |
      | -O <option list> | to specify options you want                                      |
      | -M <integer>     | to specify alternative max nodes in a time step (default is 256) |
      | -d               | give default values to everything not specified                  |
      | -csp             | to run the CSP solver                                            |
      | -nopddl          | to take graphplan type problem description                       |
      | -ns <integer>    | to specify the maximum size of nogoods to learn                  |
      | -nr <integer>    | to specify the relevance-k value                                 |
      | -cutoff <long>   | to specify the cutoff limit for CSP solver                       |
      | -ldc             | to specify the use *ldc* var-order when solving the CSP          |
      | -dlc             | to specify the use of *dlc* var-order when solving the CSP       |
      | -switch          | switch to the other var-order when over the cutoff-limit         |

     - EXAMPLES
     Example1: gpcsp -o -nopddl fixit_ops -f fixit_facts1 -O IL -d
     Run original graphplan with original input format (not pddl).
     Example2: gpcsp -csp -ldc -cutoff 50000 -o a_ops.pddl -f a_facts.pddl
     Run GP-CSP with *ldc* variable ordering with cutoff-limit of 50000.
     Example3: gpcsp -csp -ns 100 -nr 5 -o fixit_ops.pddl -f fixit_ops.pddl
     Run GP-CSP with default variable ordering (dcl), with the maximum
     nogood size of 100, and will prune all irrelevant nogoods of size>5.
     Example4: gpcsp -csp -switch -cutoff 10000 -o ......
     Run GP-CSP with the cutoff-limit of 10000. Then switch from default
     var-ordering to ldc var-ordering.
     Example5: gpcsp -csp -ldc -cutoff 100 -switch -o ....
     Similar to Example4, but switch from *ldc* var-ordering to default
     var-ordering


*** Graphplan
    - Usage of Graphplan
      #+BEGIN_SRC python
      >>> import graphplan
      >>> argv = ['graphplan', '-o', 'domain.pddl', '-f', 'problem.pddl']
      >>> graphplan.run(argv)
      #+END_SRC
 
    - Instructions about arguments:

      | OPTIONS          | DESCRIPTIONS                                                     |
      |------------------+------------------------------------------------------------------|
      | -h               | for this list                                                    |
      | -o <op file>     | to specify operator file                                         |
      | -f <fact file>   | to specify fact file                                             |
      | -t <integer>     | to specify a fixed number of time steps                          |
      | -i <info level>  | to specify info level 1 or 2 (default is 0)                      |
      | -O <option list> | to specify options you want                                      |
      | -M <integer>     | to specify alternative max nodes in a time step (default is 256) |
      | ~-d~             | give default values to everything not specified                  |
      | ~-r~             | redirect output to specified files                               |

    
      *Note*: graphplan will prompt for '*-t*' and '*-O*' during execution
    
      - Options on *'-O'*
        
        'I' means do a quick check to toss out irrelevant initial
	      conditions.  See, for example, "rocket_factsBIG"

  	    'L' is a speedup using the reasoning: if I have m goals with
  	    the property that I can create at most one of them in a
  	    given time step, then I won't be able to find a plan of
  	    fewer than m time-steps.  For instance, in a TSP problem
  	    if there are m places still to be visited, then it knows
  	    it will fail if the current time is < m.
  	    NOTE: this option currently interferes with graphplan's
  	    completeness check.

	      'S' is a speedup using the reasoning: if I have a set of goals
  	    at time t, and I've already failed on a SUBSET of these
  	    goals at time t, then we're going to fail.  Unfortunately,
  	    it seems computationally difficult to make this check, so
  	    really what Graphplan does with this option is check
  	    whether it has previously failed on some subset of size
  	    ONE SMALLER than the current set. 

        'E' turns off some of graphplan's smarts.

**** Update <2017-05-24 Wed>
     - Adding redirection of stdout to other files, the source would be '-r' flag, python would be '-out'
     

*** FF
    run() is the function which wrapped the main() function of Metric_FF
**** Metric-FF
   
     - Usage of Metric_FF(shell):
     
       A example here:

       #+BEGIN_SRC sh
       ./Metric_FF -p './' -o 'domain.pddl' -f 'probBLOCKS-4-0.pddl'
       #+END_SRC

     - Usage of Metric_FF.run()  ---->wrapped func

       A example here:

       #+BEGIN_SRC python
       >>>import Metric_FF
       >>>argv = ['./','-o','domain.pddl','-f','probBLOCKS-4-0.pddl']
       >>>Metric_FF.run(argv)
       #+END_SRC

**** Seq_Sat_FF

     - Usage of Seq_Sat_FF(shell):

       A example here:

       #+BEGIN_SRC sh
       ./Seq_Sat_FF -p './' -o 'domain.pddl' -f 'probBLOCKS-4-0.pddl'       
       #+END_SRC

     - Usage of Seq_Sat_FF.run()  ---->wrapped func

     A example here:

     #+BEGIN_SRC python
     >>>import Seq_Sat_FF
     >>>argv = ['./','-o','domain.pddl','-f','probBLOCKS-4-0.pddl']
     >>>Seq_Sat_FF.run(argv)
     #+END_SRC

**** FF_X

     - Usage of Seq_Sat_FF(shell):

     A example here:

     #+BEGIN_SRC sh
     ./Seq_Sat_FF -p './' -o 'domain.pddl' -f 'probBLOCKS-4-0.pddl'
     #+END_SRC

     - Usage of Seq_Sat_FF.run()  ---->wrapped func

     A example here:

     #+BEGIN_SRC python
     >>>import Seq_Sat_FF
     >>>argv = ['./','-o','domain.pddl','-f','probBLOCKS-4-0.paddle']
     >>>Seq_Sat_FF.run(argv)
     #+END_SRC

**** Cont_FF

     - Usage of Cont_FF(shell):

     A example here:

     #+BEGIN_SRC sh
     ./Cont_FF -p './' -o 'domain.pddl' -f 'probBLOCKS-4-0.pddl'     
     #+END_SRC


     - Usage of Cont_FF.run()  ---->wrapped func

     A example here:

     #+BEGIN_SRC python
     >>>import Cont_FF
     >>>argv = ['./','-o','domain.pddl','-f','probBLOCKS-4-0.pddl']
     >>>Cont_FF.run(argv)
     #+END_SRC

**** FF-v2.3

     - Usage of FF_2_3(shell):

     A example here:

     #+BEGIN_SRC sh
     ./FF_2_3 -p './' -o 'domain.pddl' -f 'probBLOCKS-4-0.pddl'     
     #+END_SRC


     - Usage of FF_2_3.run()

     A example here:

     #+BEGIN_SRC python
     >>>import FF_2_3
     >>>argv = ['./','-o','domain.pddl','-f','probBLOCKS-4-0.pddl']
     >>>FF_2_3.run(argv)
     #+END_SRC




*** IPP
    
** Learning
** Uncertainty
  
